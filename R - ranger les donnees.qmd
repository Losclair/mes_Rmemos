---
title: "R - Ranger les données"
author: "Losclair57"
format: html
editor: visual
---

# **TRANSFORMER LES DONNEES**

Dans ce chapitre, vous apprendrez une manière cohérente d'organiser vos données dans R à l'aide d'un système appelé **Tidy Data**. Une fois que vous disposez de données ordonnées et des outils ordonnés fournis par les packages dans le spiceverse, vous passerez beaucoup moins de temps à transférer des données d'une représentation à une autre, ce qui vous permettra de consacrer plus de temps à analiser données qui vous intéressent.\
Dans ce chapitre, vous apprendrez d'abord la définition des données ordonnées et son application sur un simple ensemble de données de jouets. Nous aborderons ensuite le principal outil que vous utiliserez pour ranger les données : le pivotement. Le pivotement vous permet de modifier la forme de vos données sans modifier aucune des valeurs.

## **Des données ordonnées**

Vous pouvez représenter les mêmes données sous-jacentes de plusieurs manières. Les exemples ci-dessous montrent les mêmes données organisées de trois manières différentes. Chaque ensemble de données montre les mêmes valeurs de quatre variables (pays , année , population et nombre de cas documentés de tuberculose), mais chaque ensemble de données organise les valeurs de manière différente.

```         
table1
#> # A tibble: 6 × 4
#>   country      year  cases population
#>   <chr>       <dbl>  <dbl>      <dbl>
#> 1 Afghanistan  1999    745   19987071
#> 2 Afghanistan  2000   2666   20595360
#> 3 Brazil       1999  37737  172006362
#> 4 Brazil       2000  80488  174504898
#> 5 China        1999 212258 1272915272
#> 6 China        2000 213766 1280428583

table2
#> # A tibble: 12 × 4
#>   country      year type           count
#>   <chr>       <dbl> <chr>          <dbl>
#> 1 Afghanistan  1999 cases            745
#> 2 Afghanistan  1999 population  19987071
#> 3 Afghanistan  2000 cases           2666
#> 4 Afghanistan  2000 population  20595360
#> 5 Brazil       1999 cases          37737
#> 6 Brazil       1999 population 172006362
#> # ℹ 6 more rows

table3
#> # A tibble: 6 × 3
#>   country      year rate             
#>   <chr>       <dbl> <chr>            
#> 1 Afghanistan  1999 745/19987071     
#> 2 Afghanistan  2000 2666/20595360    
#> 3 Brazil       1999 37737/172006362  
#> 4 Brazil       2000 80488/174504898  
#> 5 China        1999 212258/1272915272
#> 6 China        2000 213766/1280428583
```

Ce sont toutes des représentations des mêmes données sous-jacentes, mais elles ne sont pas aussi faciles à utiliser. L'un d'eux, table1, sera beaucoup plus facile à utiliser dans le Tidyverse car il est bien rangé.\
Il existe trois règles interdépendantes qui permettent de ranger un ensemble de données :\
- Chaque variable est une colonne ; chaque colonne est une variable.\
- Chaque observation est une ligne ; chaque ligne est une observation.\
- Chaque valeur est une cellule ; chaque cellule est une valeur unique.

## **Allongement des données**

Les données sont souvent organisées pour faciliter un objectif autre que l’analyse. Par exemple, il est courant que les données soient structurées de manière à faciliter la saisie des données, et non leur analyse. La plupart des gens ne connaissent pas les principes des données ordonnées.\
Cela signifie que la plupart des analyses réelles nécessiteront au moins un peu de rangement. Vous commencerez par déterminer quelles sont les variables et observations sous-jacentes.\
Tidyr fournit deux fonctions pour faire pivoter les données : `pivot_longer()` et `pivot_wider()`. Nous commencerons par commencer `pivot_longer()` car c’est le cas le plus courant.

### Données dans les noms de colonnes `pivot_longer()`

Nous allons utiliser le dataset `billboard` pour nous entrainer. Le dataset contient des éléments sur les chansons classées top 100 en 2000. Les données du tableau sont entre autre le nom de l'artiste, le titre de la chanson, la date d'entrée dans le top 100.\
Nous remarquons particulièrement un grand nombre de colonnes dont le nom commence par wk, qui correspondent au classement d'une chanson au fil des semaines qui suivent sont entrée dans le top 100. Cela ne respecte pas la règle des données ordonnées puisque les noms colonnes wk sont une variable qui conient d'autres variables (le numéro de la semaine **et** le rang de la chanson).

```{r}
View(billboard)
```

Pour ranger ces données, nous utiliserons `pivot_longer()`.

```{r}
billboard |> 
  pivot_longer(
    cols = starts_with("wk"), 
    names_to = "week", 
    values_to = "rank"
  )
```

Nous observons que la colonne contient maintenant les noms de semaines, ce qui n'est pas pratique pour en faire une étude. Transformons (avec `mutate` et `parse_number`) ses noms de semaines en nombre.

```{r}
billboard_longer <- billboard |> 
  pivot_longer(
    cols = starts_with("wk"), 
    names_to = "week", 
    values_to = "rank",
    values_drop_na = TRUE
  ) |> 
  mutate(
    week = parse_number(week)
  )
billboard_longer
```

```{r}
billboard_longer |> 
  ggplot(aes(x = week, y = rank, group = track)) + 
  geom_line(alpha = 0.25) + 
  scale_y_reverse()
```

### Comment fonctionne le pivotement ?

Ci-dessous les données de travail.

```{r}
df <- tribble(
  ~id,  ~bp1, ~bp2,
   "A",  100,  120,
   "B",  140,  115,
   "C",  120,  125
)
```

Nous voulons que notre nouvel ensemble de données ait trois variables : id(existe déjà), measurement(les noms des colonnes) et value(les valeurs des cellules). Pour y parvenir, nous devons pivoter df.

```{r}
df |> 
  pivot_longer(
    cols = bp1:bp2,
    names_to = "measurement",
    values_to = "value"
  )
```

oussons l'exemple plus loin, avec une tabl avec des nom plus compliqués.

```{r}
who2
```

```{r}
who2 |> 
  pivot_longer(
    cols = !(country:year),
    names_to = c("diagnosis", "gender", "age"), 
    names_sep = "_",
    values_to = "count"
  )
```

Et encore plus compliq;ué avec

```{r}
household
```

```{r}
household |> 
  pivot_longer(
    cols = !family, 
    names_to = c(".value", "child"), 
    names_sep = "_", 
    values_drop_na = TRUE
  )
```

### Données de type colonne dans les valeurs `pivot_wider()`

```{r}
cms_patient_experience
```

L'unité centrale étudiée est une organisation, mais chaque organisation est répartie sur six lignes, avec une ligne pour chaque mesure prise dans l'organisation d'enquête. Nous pouvons voir l'ensemble complet des valeurs pour measure_cdet measure_titleen utilisantdistinct() :

```{r}
cms_patient_experience |> 
  distinct(measure_cd, measure_title)
```

```{r}
cms_patient_experience |> 
  pivot_wider(
    names_from = measure_cd,
    values_from = prf_rate
  )
```

Pas concluant, trop de lignes avec des noms identiques. Essayons plutôt:

```{r}
cms_patient_experience |> 
  pivot_wider(
    id_cols = starts_with("org"),
    names_from = measure_cd,
    values_from = prf_rate
  )
```

## **LES TYPES DE DONNEES**

### **Les vecteurs logiques**

Les vecteurs logiques sont les plus simples, avec seulement trois valeurs possibles :\

-   `TRUE`\
-   `FALSE`\
-   `NA`

Les vecteurs logiques sont fréquemment le résultat de nos propres actions sur les données lors de comparaisons numériques. Nous pouvons les combiner et appliquer des fonctions utiles sur ces vecteurs.

#### *Préparation des données de travail*

```{r}
library(tidyverse)
library(nycflights13)

x <- c(1, 2, 3, 5, 7, 11, 13)

df <- tibble(x)
df |> 
  mutate(y = x * 2)
```

#### *Comparaisons*

Une manière très courante de créer un vecteur logique consiste à effectuer une comparaison numérique avec \<, \<=, \>, \>=, !=et ==. Jusqu'à présent, nous avons principalement créé des variables logiques de manière transitoire avec `filter()`.\
Elles sont calculées, utilisées, puis jetées. Par exemple, le filtre suivant recherche tous les départs de jour qui arrivent à peu près à l'heure.

```{r}
flights |> 
  filter(dep_time > 600 & dep_time < 2000 & abs(arr_delay) < 20)
```

La manipulation que nous venons de faire inclue l'utilisation de vecteur booléens que nous pouvons présenter avec `mutate()`.

```{r}
flights |> 
  mutate(
    daytime = dep_time > 600 & dep_time < 2000,
    approx_ontime = abs(arr_delay) < 20,
    .keep = "used"
  )
```

Le résultat de `filter()` est la sélection des lignes dont daytime et approx_ontime sont `TRUE`.

```{r}
flights |> 
  mutate(
    daytime = dep_time > 600 & dep_time < 2000,
    approx_ontime = abs(arr_delay) < 20,
  ) |> 
  filter(daytime & approx_ontime)
```

1.  Les comparaison en virgule flottante

**Les comparaisons entre 2 nombres dont un qui est un nombre décimal peuvent être fausse (si la valeur est très proche), par exemple 1 n'est pas égal à 0.9999999999999. Si nous souhaitons faire fi de cette vérité mathématique nous pouvons utiliser `near()`.\
Ainsi near(1, 0.9999999999999) donnera pour résultat `TRUE`.**

##### Et que faire avec les valeurs manquantes ?

Par nature, une opération impliquant une valeur inconnue entraine un résultat inconnu, logique. A noter que `NA == NA` donne pour solution `NA`.

2.  is.na()

Renvoi TRUE si la valeur testée est NA.

#### *Algèbre booléenne*

Ce sont les opérateurs `&`, `|`, `!` et ce qui semble être une fonction  `xor()`.
